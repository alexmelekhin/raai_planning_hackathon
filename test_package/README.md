# Задачи и замечания:

- Нужны лучшие чекеры.
- ~~Организовать в path finder-е проверку check_if_point_soft_valid и начинать поиск с первой свободной точки, потому что если начинать поиск с софт буффера, то не найдем.~~
- Добавить остановку робота и сброс флага, если path finder не справился.
- Добавить остановку робота и сброс флага, если оптимайзер не справился.
- ~~Разобраться со случаем большого начального маршрута.~~
- Решение о пересечении траектории – очень грубое, подумать получше.
- Allowed distance в path finder-е не работает для S траекторий. Добавить ручное заполнение карты невалидными клетками.
- ~~Добавить сэмплинг с нужным разрешением начального маршрута.~~
- Петля в траектории - доработать и вернуть прунинг.
- Плохо срезает большие углы.

# Имеющиеся инструменты:

- Общий класс TrajectoryOptimizer, вкллючающий поля, хранящие начальный и объездной маршруты и флаг переиспользования траектории
- Вспомогательные классы RouteProcessor, PathFinder, Checker
- Много вспомогательных функций в Utils.cpp, включая функции расстановки препятствий
- Отдельно вынесенные функции ACADO_solution и acado_solve

# Общая концепция:

## Начальная итерация:

- Получаем маршрут, приравниваем его к соответствующим полям в классе TrajectoryOptimizer.
- Отправляем маршрут в класс RouteProcessor, чтобы вырезать локальный участок, который будет рассматриваться на данном этапе.
- Чекаем маршрут на проходимость.
- Если маршрут проходимый,берем его как есть. Если нет, отправляем в класс PathFinder и находим объезд.
- Расставляем препятствия вдоль участка маршрута.
- Отправляем участок в оптимизатор.
- Публикуем результаты.

## Последующие итерации:

- Чекаем имеющуюся на данный момент траекторию на близость к конечной точке маршрута и на проходимость.
- Если траектория непроходима, пересчитываем весь участок.
- Если траектория проходима, берем участок для пересчета, определяемый параметром recompute_points и проделываем для него все операции из начальной итерации, начиная с расстановки препятствий.

# Детальная процедура:

## Начальная итерация:

1. Получаю начальный маршрут.
2. Сэмплю с нужным разрешением, если начальный маршрут > 0, приравниваю объездной маршрут к начальному, очищаю траекторию, ставлю флаг реюза в 0, начинаю процедуру поиска.
3. Если траектория ненулевая, чекаю ближайшую точку. Если она совпадает с ближайшей точкой маршрута, выхожу из расчета. Если траектория невалидна, должен остановиться (работает нестабильно). Если точка не конечная, проверяю траекторию на валидность и выставляю флаг реюза в 1 если валидна, в 0 если невалидна.
4. Получаю текущую позу робота, вхожу в роут препроцессинг.
5. Беру от роута первые closest_points точек, ищу ближайшую из них к позе. Проверяю расстояние до нее, если слишком далеко, ставлю флаг в 1. Отрезаю все точки до нее.
6. Проверяю, сколько точек в оставшемся после отреза пути. Если больше, чем N_path, то беру первые N_path точек и работаю с ними. Если меньше, беру столько, сколько есть. Приравниваю полученные отрезки к init_path и path_around_obstacles. Вхожу в поиск JPS.
7. Проверяю путь на софт валидность. Расставляю краевые точки до и после софт буффера. Нахожу JPS-ом путь между этими точками. Если препятствие стоит на конечной точке пути - беру в качестве конечной точки последнюю свободную точку до софт буффера, обрезаю остальные в init_path и path_around_obstacles.
8. Вставляю найденный путь в current_path_around_obstacles и приравниваю линейную скорость в path_around_obstacles к 1. Визуализирую current_path_around_obstacles. Перехожу к расстановке препятствий.
9. Расставляю препятствия вокруг init_path и path_around_obstacles, а также вокруг параллельных им путей на 2 метра влево и вправо. Фильтрую препятствия. Перехожу в решение ACADO.
10. Решаю задачу с помощью ACADO, проверяю на успех и на валидность. Если проверки пройдены, публикую.

## Последующие итерации:

1. Чекаю, сколько я проехал от последней точки, прибавляю это расстояние к конечной точки рассчитываемого участка пути.
2. Чекаю, не появилось ли препятствие на объездном маршруте.
	а) Если нет, двигаюсь дальше.
	б) Если есть препятствие, выставляю флаг в 0, скармливаю участок path-finder-у и перехожу к пункту 5 начальной итерации.
3. Рассчитываю, какие точки надо пересчитать (размер участка минус дефолтный размер пересчета плюс добавленное в пункте 1 расстояние)
4. Скармливаю пересчитываемый кусок участка решателю, публикую, выставляю флаг в 1.